#include <ArduinoJson.h>
#include <SoftwareSerial.h>  // Th√™m th∆∞ vi·ªán SoftwareSerial

// C·∫£m bi·∫øn v√† relay
const int RAIN_SENSOR_PIN = 7;
const int SOIL_SENSOR_PIN = A0;
const int PUMP_RELAY_PIN = 8;

// SoftwareSerial v·ªõi ESP32 (ch√¢n 4 = RX, ch√¢n 5 = TX)
SoftwareSerial ESP32Serial(4, 5); // RX, TX

// LED b√°o tr·∫°ng th√°i (t√πy ch·ªçn)
const int STATUS_LED = 13;

// Bi·∫øn tr·∫°ng th√°i
bool pumpState = false;
bool lastPumpState = false;
unsigned long lastSendTime = 0;
unsigned long lastConnectionCheck = 0;
const long SEND_INTERVAL = 2000;
const long CONNECTION_TIMEOUT = 10000; // 10 gi√¢y kh√¥ng c√≥ data = m·∫•t k·∫øt n·ªëi
bool espConnected = false;

// Calibration values - ƒëi·ªÅu ch·ªânh theo c·∫£m bi·∫øn th·ª±c t·∫ø
const int DRY_VALUE = 1000;   // Kh√¥ (trong kh√¥ng kh√≠)
const int WET_VALUE = 300;    // ∆Ø·ªõt (trong n∆∞·ªõc)

void setup() {
  Serial.begin(9600); // For debugging
  ESP32Serial.begin(9600); // SoftwareSerial v·ªõi ESP32
  
  pinMode(RAIN_SENSOR_PIN, INPUT);
  pinMode(PUMP_RELAY_PIN, OUTPUT);
  pinMode(STATUS_LED, OUTPUT);
  digitalWrite(PUMP_RELAY_PIN, HIGH); // T·∫Øt b∆°m
  
  Serial.println("üöÄ Arduino Uno R3 - Smart Irrigation System");
  Serial.println("üì§ Send interval: 2 seconds");
  Serial.println("üì° SoftwareSerial on pins: RX=4, TX=5");
  Serial.println("‚è≥ Waiting for ESP32 connection...");
  
  // Nh·∫•p nh√°y LED 3 l·∫ßn khi kh·ªüi ƒë·ªông
  for (int i = 0; i < 3; i++) {
    digitalWrite(STATUS_LED, HIGH);
    delay(200);
    digitalWrite(STATUS_LED, LOW);
    delay(200);
  }
}

void loop() {
  // 1. Ki·ªÉm tra k·∫øt n·ªëi ESP32
  checkESPConnection();
  
  // 2. ƒêi·ªÅu khi·ªÉn Relay theo l·ªánh t·ª´ ESP32
  controlPumpFromESP();
  
  // 3. ƒê·ªçc c·∫£m bi·∫øn v√† g·ª≠i d·ªØ li·ªáu ƒë·ªãnh k·ª≥
  if (millis() - lastSendTime >= SEND_INTERVAL) {
    sendSensorData();
    lastSendTime = millis();
    
    // C·∫≠p nh·∫≠t th·ªùi gian k·∫øt n·ªëi
    if (espConnected) {
      lastConnectionCheck = millis();
    }
  }
  
  // 4. Debug status m·ªói 10 gi√¢y
  debugStatus();
  
  // 5. ƒêi·ªÅu khi·ªÉn LED tr·∫°ng th√°i
  controlStatusLED();
  
  delay(10);
}

// ƒê·ªçc c·∫£m bi·∫øn m∆∞a
int readRainSensor() {
  return digitalRead(RAIN_SENSOR_PIN) == LOW ? 1 : 0; // LOW = M∆∞a
}

// ƒê·ªçc c·∫£m bi·∫øn ƒë·ªô ·∫©m ƒë·∫•t (c·∫£i thi·ªán ƒë·ªô ·ªïn ƒë·ªãnh)
int readSoilMoisture() {
  // ƒê·ªçc nhi·ªÅu l·∫ßn ƒë·ªÉ l·∫•y gi√° tr·ªã trung b√¨nh
  int readings = 5;
  int total = 0;
  
  for (int i = 0; i < readings; i++) {
    total += analogRead(SOIL_SENSOR_PIN);
    delay(2);
  }
  
  int rawValue = total / readings;
  
  // Gi·ªõi h·∫°n gi√° tr·ªã
  if (rawValue > DRY_VALUE) rawValue = DRY_VALUE;
  if (rawValue < WET_VALUE) rawValue = WET_VALUE;
  
  // Chuy·ªÉn ƒë·ªïi th√†nh ph·∫ßn trƒÉm (ƒë·∫£o ng∆∞·ª£c)
  int percentage = map(rawValue, DRY_VALUE, WET_VALUE, 0, 100);
  return constrain(percentage, 0, 100);
}

// Ki·ªÉm tra k·∫øt n·ªëi ESP32
void checkESPConnection() {
  static unsigned long lastDataReceived = 0;
  
  if (ESP32Serial.available()) {
    lastDataReceived = millis();
    if (!espConnected) {
      espConnected = true;
      Serial.println("‚úÖ ESP32 Connected via SoftwareSerial!");
    }
  }
  
  // N·∫øu qu√° 10 gi√¢y kh√¥ng nh·∫≠n ƒë∆∞·ª£c data
  if (espConnected && (millis() - lastDataReceived > CONNECTION_TIMEOUT)) {
    espConnected = false;
    Serial.println("‚ö†Ô∏è ESP32 Connection Lost!");
    
    // T·ª± ƒë·ªông t·∫Øt b∆°m khi m·∫•t k·∫øt n·ªëi (an to√†n)
    if (pumpState) {
      digitalWrite(PUMP_RELAY_PIN, HIGH);
      pumpState = false;
      Serial.println("üî¥ Auto Pump OFF (safety)");
    }
  }
}

// ƒêi·ªÅu khi·ªÉn b∆°m t·ª´ ESP32
void controlPumpFromESP() {
  if (ESP32Serial.available()) {
    String command = ESP32Serial.readStringUntil('\n');
    command.trim();
    
    // Ghi nh·∫≠n c√≥ data t·ª´ ESP32
    lastConnectionCheck = millis();
    
    Serial.print("üì® From ESP32: ");
    Serial.println(command);
    
    if (command == "PUMP_ON") {
      digitalWrite(PUMP_RELAY_PIN, LOW); // B·∫≠t relay (LOW k√≠ch ho·∫°t relay)
      pumpState = true;
      ESP32Serial.println("PUMP_ON_ACK");
      Serial.println("üî¥ Pump ON");
    } 
    else if (command == "PUMP_OFF") {
      digitalWrite(PUMP_RELAY_PIN, HIGH); // T·∫Øt relay (HIGH t·∫Øt relay)
      pumpState = false;
      ESP32Serial.println("PUMP_OFF_ACK");
      Serial.println("üü¢ Pump OFF");
    }
    // X·ª≠ l√Ω c√°c l·ªánh kh√°c n·∫øu c√≥
    else if (command.startsWith("TEST")) {
      ESP32Serial.println("UNO_OK");
      Serial.println("‚úÖ Test command received");
    }
    else if (command == "GET_STATUS") {
      sendSensorData(); // G·ª≠i ngay d·ªØ li·ªáu
    }
  }
}

// G·ª≠i d·ªØ li·ªáu c·∫£m bi·∫øn
void sendSensorData() {
  StaticJsonDocument<200> doc;

  doc["soil_moisture"] = readSoilMoisture();
  doc["rain"] = readRainSensor();
  doc["pump_status"] = pumpState;

  String jsonString;
  serializeJson(doc, jsonString);

  // G·ª≠i ƒë·∫øn ESP32 qua SoftwareSerial
  ESP32Serial.println(jsonString);

  // Debug
  Serial.print("üì§ To ESP32: ");
  Serial.println(jsonString);
}

// H√†m debug tr·∫°ng th√°i
void debugStatus() {
  static unsigned long lastDebug = 0;
  if (millis() - lastDebug >= 10000) {
    Serial.println("\n=== ARDUINO UNO STATUS ===");
    Serial.print("Soil Moisture: ");
    Serial.print(readSoilMoisture());
    Serial.println("%");
    Serial.print("Rain Sensor: ");
    Serial.println(readRainSensor() ? "RAINING" : "DRY");
    Serial.print("Pump State: ");
    Serial.println(pumpState ? "ON" : "OFF");
    Serial.print("ESP32 Connection: ");
    Serial.println(espConnected ? "‚úÖ CONNECTED" : "‚ùå DISCONNECTED");
    Serial.print("Uptime: ");
    Serial.print(millis() / 1000);
    Serial.println(" seconds");
    Serial.println("==========================\n");
    lastDebug = millis();
  }
}

// ƒêi·ªÅu khi·ªÉn LED tr·∫°ng th√°i
void controlStatusLED() {
  static unsigned long lastBlink = 0;
  static bool ledState = false;
  
  if (!espConnected) {
    // Nh·∫•p nh√°y nhanh khi m·∫•t k·∫øt n·ªëi (200ms)
    if (millis() - lastBlink > 200) {
      digitalWrite(STATUS_LED, ledState);
      ledState = !ledState;
      lastBlink = millis();
    }
  } else if (pumpState) {
    // B·∫≠t s√°ng khi b∆°m ƒëang ch·∫°y
    digitalWrite(STATUS_LED, HIGH);
  } else {
    // Nh·∫•p nh√°y ch·∫≠m khi k·∫øt n·ªëi b√¨nh th∆∞·ªùng (1000ms)
    if (millis() - lastBlink > 1000) {
      digitalWrite(STATUS_LED, ledState);
      ledState = !ledState;
      lastBlink = millis();
    }
  }
}

// H√†m kh·∫©n c·∫•p - t·∫Øt b∆°m ngay l·∫≠p t·ª©c
void emergencyStop() {
  digitalWrite(PUMP_RELAY_PIN, HIGH);
  pumpState = false;
  ESP32Serial.println("EMERGENCY_STOP");
  Serial.println("üö® EMERGENCY STOP - Pump OFF");
}

// H√†m test SoftwareSerial (c√≥ th·ªÉ g·ªçi t·ª´ Serial Monitor)
void testSerial() {
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    
    if (cmd == "test") {
      Serial.println("Testing SoftwareSerial...");
      ESP32Serial.println("HELLO_ESP32");
      Serial.println("Sent: HELLO_ESP32");
    }
    else if (cmd == "pumpon") {
      digitalWrite(PUMP_RELAY_PIN, LOW);
      pumpState = true;
      Serial.println("Manual Pump ON");
    }
    else if (cmd == "pumpoff") {
      digitalWrite(PUMP_RELAY_PIN, HIGH);
      pumpState = false;
      Serial.println("Manual Pump OFF");
    }
  }
}